<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle PL/SQL Practice Questions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            color: #333;
        }
        .question {
            margin-bottom: 30px;
            padding: 15px;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        .question-number {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }
        .options {
            margin: 10px 0;
        }
        .option {
            margin: 5px 0;
        }
        .answer {
            font-weight: bold;
            color: #28a745;
            margin: 10px 0;
        }
        .explanation {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .code {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Oracle PL/SQL Practice Questions</h1>

    <div class="question">
        <div class="question-number">Question 1: Q101</div>
        <p>Which of the following identifiers are valid in PL/SQL?</p>
        <div class="options">
            <div class="option">1. total#amount</div>
            <div class="option">2. 2nd_chance</div>
            <div class="option">3. employee-name</div>
            <div class="option">4. $_bonus</div>
            <div class="option">5. A1B2C3</div>
            <div class="option">6. #salary</div>
            <div class="option">7. my_variable</div>
        </div>
        <div class="answer">Answer: 1, 5, and 7</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li>total#amount: Valid. It starts with a letter and contains only letters, numbers, underscores, and hash sign.</li>
                <li>2nd_chance: Invalid. It starts with a number, which is not allowed as the starting character in PL/SQL identifiers.</li>
                <li>employee-name: Invalid. It contains a hyphen, which is not allowed in PL/SQL identifiers.</li>
                <li>$_bonus: Invalid. It starts with a dollar sign, which is not allowed as the starting character in PL/SQL identifiers.</li>
                <li>A1B2C3: Valid. It starts with a letter and contains only letters and numbers.</li>
                <li>#salary: Invalid. It starts with a hash sign, which is not allowed as the starting character in PL/SQL identifiers.</li>
                <li>my_variable: Valid. It starts with a letter and contains only letters and underscores.</li>
            </ul>
            <p>Valid Identifiers: total#amount, A1B2C3, my_variable</p>
            <p><strong>Topic:</strong> Recognize valid and invalid identifiers.</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 2: Q102</div>
        <p>When declaring a VARCHAR2 variable in PL/SQL without specifying its size, what happens?</p>
        <div class="options">
            <div class="option">It defaults to a size of 1.</div>
            <div class="option">It defaults to a maximum size of 4000.</div>
            <div class="option">It raises a compilation error.</div>
            <div class="option">The size becomes dynamic based on the assigned value.</div>
        </div>
        <div class="answer">Answer: It raises a compilation error.</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <p>In PL/SQL, when you declare a VARCHAR2 variable without specifying its size, the declaration will result in a compilation error. Unlike some other programming environments, PL/SQL requires that you explicitly specify the size for a VARCHAR2 variable when you declare it.</p>
            <p>For example, the following declaration will result in an error:</p>
            <div class="code">DECLARE
    v_name VARCHAR2;
BEGIN
    NULL;
END;</div>
            <p>To correct this, you should specify the size:</p>
            <div class="code">DECLARE
    v_name VARCHAR2(50);
BEGIN
    NULL;
END;</div>
            <p><strong>Topic:</strong> Declaring PL/SQL Variables</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 3: Q103</div>
        <p>What will be the output of the following code?</p>
        <div class="code">set SERVEROUTPUT ON;
declare
    v_bool boolean := TRUE;
begin
    if v_bool then
        dbms_output.put_line('Yes');
    else
        dbms_output.put_line('No');
    end if;
    
    declare
        v_bool boolean := FALSE;
    begin
        if v_bool then
            dbms_output.put_line('Yes');
        else
            dbms_output.put_line('No');
        end if;
    end;
end;</div>
        <div class="options">
            <div class="option">Yes No</div>
            <div class="option">No Yes</div>
            <div class="option">Yes Yes</div>
            <div class="option">No No</div>
        </div>
        <div class="answer">Answer: Yes No</div>
    </div>

    <div class="question">
        <div class="question-number">Question 4: Q104</div>
        <p>Consider the following PL/SQL block:</p>
        <div class="code">set SERVEROUTPUT ON;
DECLARE
    v_num NUMBER := 10;
BEGIN
    v_num := v_num + &bind_value;
    IF v_num > 20 THEN
        v_num := v_num - 10;
    ELSIF v_num < 10 THEN
        v_num := v_num + 10;
    END IF;
    DBMS_OUTPUT.PUT_LINE(v_num);
END;</div>
        <p>If the bind variable bind_value is set to -5, what will be the output?</p>
        <div class="options">
            <div class="option">15</div>
            <div class="option">5</div>
            <div class="option">20</div>
            <div class="option">25</div>
        </div>
        <div class="answer">Answer: 15</div>
    </div>

    <div class="question">
        <div class="question-number">Question 5: Q105</div>
        <p>Examine the following PL/SQL code:</p>
        <div class="code">set SERVEROUTPUT ON;
DECLARE
    v_number NUMBER := :bind_number;
    v_string VARCHAR2(50);
BEGIN
    v_string := CASE
        WHEN v_number BETWEEN 1 AND 5 THEN 'Range 1-5'
        WHEN v_number BETWEEN 6 AND 10 THEN 'Range 6-10'
        ELSE 'Out of Range'
    END;
    
    FOR i IN 1 .. 3 LOOP
        IF v_string = 'Range 6-10' AND i = 2 THEN
            v_string := 'Middle Range';
            CONTINUE;
        END IF;
        v_string := 'Iteration ' || i;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE(v_string);
END;</div>
        <p>If the bind variable bind_number is set to 7, what will be the output?</p>
        <div class="options">
            <div class="option">Range 6-10</div>
            <div class="option">Iteration 1</div>
            <div class="option">Middle Range</div>
            <div class="option">Iteration 3</div>
        </div>
        <div class="answer">Answer: Iteration 3</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ol>
                <li>The bind variable bind_number is set to 7</li>
                <li>The variable v_number is initialized with the value 7</li>
                <li>The CASE statement checks the value of v_number. Since v_number is 7, the condition WHEN v_number BETWEEN 6 AND 10 is TRUE. So, v_string is set to 'Range 6-10'</li>
                <li>The FOR loop runs 3 times</li>
                <li>On the first iteration (i = 1), the IF condition is not met, so v_string is set to 'Iteration 1'</li>
                <li>On the second iteration (i = 2), the IF condition v_string = 'Range 6-10' AND i = 2 is FALSE (because v_string was set to 'Iteration 1' in the previous loop). So, v_string is set to 'Iteration 2'</li>
                <li>On the third iteration (i = 3), the IF condition is not met again, so v_string is set to 'Iteration 3'</li>
                <li>Finally, DBMS_OUTPUT.PUT_LINE(v_string); will print the value of v_string, which is 'Iteration 3'</li>
            </ol>
            <p><strong>Topics:</strong> Declaring PL/SQL Variables, Writing Executable Statements, Writing Control Structures</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 6: Q106</div>
        <p>Consider the following PL/SQL subprogram:</p>
        <div class="code">set SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE print_multiples(n NUMBER, limit_val NUMBER) IS
BEGIN
    FOR i IN 1 .. limit_val LOOP
        IF MOD(i, n) = 0 THEN
            DBMS_OUTPUT.PUT_LINE(i);
        END IF;
    END LOOP;
END;</div>
        <p>Which numbers will be printed if the procedure is invoked as print_multiples(3, 10)?</p>
        <div class="options">
            <div class="option">1, 2, 3, ... , 10</div>
            <div class="option">3, 6, 9</div>
            <div class="option">3, 6, 9, 12</div>
            <div class="option">1, 4, 7, 10</div>
        </div>
        <div class="answer">Answer: 3, 6, 9</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <p>Given the invocation print_multiples(3, 10), the procedure will print all multiples of 3 between 1 and 10.</p>
            <p>Let's break it down:</p>
            <ul>
                <li>For i = 1: MOD(1, 3) is 1, so it's not printed.</li>
                <li>For i = 2: MOD(2, 3) is 2, so it's not printed.</li>
                <li>For i = 3: MOD(3, 3) is 0, so 3 is printed.</li>
                <li>For i = 4: MOD(4, 3) is 1, so it's not printed.</li>
                <li>For i = 5: MOD(5, 3) is 2, so it's not printed.</li>
                <li>For i = 6: MOD(6, 3) is 0, so 6 is printed.</li>
                <li>For i = 7: MOD(7, 3) is 1, so it's not printed.</li>
                <li>For i = 8: MOD(8, 3) is 2, so it's not printed.</li>
                <li>For i = 9: MOD(9, 3) is 0, so 9 is printed.</li>
                <li>For i = 10: MOD(10, 3) is 1, so it's not printed.</li>
            </ul>
            <p>So, the numbers that will be printed are: 3, 6, 9</p>
            <p><strong>Topics:</strong> Using PL/SQL Subprograms, Creating Procedures and Using Parameters, Writing Control Structures</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 7: Q107</div>
        <p>You work as a Database Developer for NovaTech Inc. The company uses an Oracle database. The database contains two tables named Customers and Change_Log. You are tasked with creating a trigger that tracks every new customer added to the Customers table and logs the details of the added rows in the Change_Log table. How will you achieve this?</p>
        <div class="options">
            <div class="option">Create a statement trigger on the Change_Log table.</div>
            <div class="option">Create a statement trigger on the Customers table.</div>
            <div class="option">Create a row trigger on the Change_Log table.</div>
            <div class="option">Create a row trigger on the Customers table.</div>
        </div>
        <div class="answer">Answer: Create a row trigger on the Customers table.</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>Statement Trigger:</strong> Executes once for each triggering statement, regardless of the number of rows affected. Not suitable for logging individual row changes, as it does not have the context of each row affected by the triggering statement.</li>
                <li><strong>Row Trigger:</strong> Executes once for each row affected by the triggering statement. Ideal for tasks that need to address individual row changes, as it provides the context of the current row being processed.</li>
            </ul>
            <p><strong>Appropriate Trigger for the Task:</strong></p>
            <p>Since the requirement is to track and log details for each new customer individually, a row trigger on the "Customers" table is appropriate. This row trigger will fire for each new row inserted into the "Customers" table. Within the trigger, you can capture the details of the new customer and insert a corresponding entry into the "Change_Log" table.</p>
            <p><strong>Topic:</strong> Creating Compound, DDL, and Event Database Triggers</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 8: Q108</div>
        <p>Given the following collection declaration:</p>
        <div class="code">TYPE StrLst IS TABLE OF VARCHAR2(50);
s StrLst := StrLst('Apple', 'Banana', 'Cherry', 'Date', 'Fig');</div>
        <p>Which of the following methods will eliminate the last element from the collection?</p>
        <div class="options">
            <div class="option">DELETE(1,5)</div>
            <div class="option">TRIM</div>
            <div class="option">DELETE</div>
            <div class="option">TRIM(5)</div>
        </div>
        <div class="answer">Answer: TRIM</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>DELETE(1,5):</strong> This method is not valid for the DELETE method of collections. The DELETE method can take either a single index or two indices, but when two indices are provided, it deletes elements from the start index to the end index, inclusive. In this case, it would delete all elements from the first to the fifth, which is not the desired outcome of removing just the last element.</li>
                <li><strong>TRIM (Correct):</strong> The TRIM method, when used without any parameters, removes the last element from a collection. This is the primary method to achieve the desired outcome without needing to know the index of the last element.</li>
                <li><strong>DELETE:</strong> When used without any parameters, the DELETE method removes all elements from the collection, effectively emptying it. This is not the desired outcome, as we only want to remove the last element.</li>
                <li><strong>TRIM(5):</strong> The TRIM method can take a single parameter that specifies the number of elements to remove from the end of the collection. In this case, TRIM(5) would remove the last five elements, which would effectively empty the entire collection. This is not the desired outcome, as we only want to remove one element.</li>
            </ul>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 9: Q109</div>
        <p>Which of the following data types in PL/SQL is used to store year, month, and day values without the need for high-level precision and time-zone awareness?</p>
        <div class="options">
            <div class="option">DATE</div>
            <div class="option">TIMESTAMP</div>
            <div class="option">TIMESTAMP WITH LOCAL TIME ZONE</div>
            <div class="option">TIMESTAMP WITH TIME ZONE</div>
        </div>
        <div class="answer">Answer: DATE</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>DATE:</strong> The DATE data type in PL/SQL is used to store date and time values. It includes the year, month, day, hour, minute, and second. However, it does not store fractional seconds or time zone information. It's commonly used when you need to store or manipulate date and time values without the need for high precision or time zone awareness.</li>
                <li><strong>TIMESTAMP:</strong> The TIMESTAMP data type is an extension of the DATE data type. It stores year, month, day, hour, minute, second, and fractional seconds. This allows for more precision than the DATE type. It's used when you need to store or manipulate date and time values with high precision, such as logging events down to the millisecond.</li>
                <li><strong>TIMESTAMP WITH LOCAL TIME ZONE:</strong> This data type is similar to the TIMESTAMP, but it also considers the time zone of the database server. When data is stored, it's converted to the database time zone. When retrieved, it's converted to the local time zone of the session. It's beneficial when you have users or systems in different time zones and you want to standardize the stored times, but display them in the local time zone of the user or system.</li>
                <li><strong>TIMESTAMP WITH TIME ZONE:</strong> This data type stores the date, time, fractional seconds, and the time zone displacement. The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time).</li>
            </ul>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 10: Q110</div>
        <p>Which of the following clauses in PL/SQL is used to fetch a single row from the result set of a cursor into a record variable?</p>
        <div class="options">
            <div class="option">OPEN CURSOR</div>
            <div class="option">FETCH INTO</div>
            <div class="option">DECLARE CURSOR</div>
            <div class="option">CLOSE CURSOR</div>
        </div>
        <div class="answer">Answer: FETCH INTO</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>OPEN CURSOR:</strong> The OPEN statement in PL/SQL is used to open a cursor, which prepares the cursor to fetch rows returned by a SQL query. It's the initial step when working with explicit cursors, allowing subsequent fetch operations.</li>
                <li><strong>FETCH INTO:</strong> The FETCH INTO statement in PL/SQL is used to retrieve a single row from the result set of a cursor and store it into a record variable or individual variables. It's commonly used in cursor operations when you want to process rows one at a time. After fetching, operations can be performed on the retrieved data.</li>
                <li><strong>DECLARE CURSOR:</strong> The DECLARE CURSOR statement in PL/SQL is used to define a cursor with a specific SQL query. It's the first step in defining an explicit cursor, specifying which rows you're interested in processing.</li>
                <li><strong>CLOSE CURSOR:</strong> The CLOSE statement in PL/SQL is used to close a cursor, releasing the memory and resources associated with it. It's the final step in cursor operations, ensuring that resources are freed up after processing the desired rows.</li>
            </ul>
            <p><strong>Topic:</strong> Using Explicit Cursors</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 11: Q111</div>
        <p>In which of the following scenarios is it essential to utilize an explicit cursor in PL/SQL?</p>
        <div class="options">
            <div class="option">When retrieving data from multiple tables using a JOIN operation</div>
            <div class="option">When a query is expected to produce multiple results</div>
            <div class="option">When executing a query that uses aggregate functions</div>
            <div class="option">When executing a single-row SELECT statement with a WHERE clause</div>
        </div>
        <div class="answer">Answer: When a query is expected to produce multiple results</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>When retrieving data from multiple tables using a JOIN operation:</strong> While JOIN operations often retrieve data from multiple tables, the use of an explicit cursor is not strictly necessary based on the JOIN operation alone. It depends more on the number of rows the query is expected to return.</li>
                <li><strong>When a query is expected to produce multiple results:</strong> This is accurate. When a query is anticipated to return more than one row, an explicit cursor is typically used in PL/SQL to handle and process each row individually.</li>
                <li><strong>When executing a query that uses aggregate functions:</strong> Aggregate functions like SUM, AVG, MAX, etc., usually return a single value. Therefore, an explicit cursor is not strictly necessary for such queries.</li>
                <li><strong>When executing a single-row SELECT statement with a WHERE clause:</strong> If a SELECT statement with a WHERE clause is designed to return only a single row, then an explicit cursor is not strictly required. One can use implicit cursors or direct assignment in PL/SQL.</li>
            </ul>
            <p><strong>Topic:</strong> Using Explicit Cursors</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 12: Q112</div>
        <p>You are employed as a Database Developer for WebTech Solutions. The company utilizes an Oracle database. You are tasked with executing a PL/SQL block that requires the use of dynamic SQL for varying table names. Which of the following Oracle provided packages will assist you in achieving this?</p>
        <div class="options">
            <div class="option">DBMS_ALERT</div>
            <div class="option">DBMS_SCHEDULER</div>
            <div class="option">DBMS_OUTPUT</div>
            <div class="option">DBMS_SQL</div>
        </div>
        <div class="answer">Answer: DBMS_SQL</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>DBMS_ALERT:</strong> The DBMS_ALERT package is used for asynchronous notification of database events. It's not specifically designed for dynamic SQL execution.</li>
                <li><strong>DBMS_SCHEDULER:</strong> The DBMS_SCHEDULER package is used for creating, managing, and controlling jobs that are performed on a scheduled basis. It doesn't directly deal with dynamic SQL.</li>
                <li><strong>DBMS_OUTPUT:</strong> The DBMS_OUTPUT package is used to display output, debug information, or messages from PL/SQL blocks, subprograms, and triggers. It's not used for executing dynamic SQL.</li>
                <li><strong>DBMS_SQL:</strong> The DBMS_SQL package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL. It's the appropriate choice for executing dynamic SQL.</li>
            </ul>
            <p><strong>Topic:</strong> Using Dynamic SQL</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 13: Q113</div>
        <p>Given the following PL/SQL package specification:</p>
        <div class="code">CREATE OR REPLACE PACKAGE overload IS
    PROCEDURE test(p_first NUMBER);
    PROCEDURE test(p_in NUMBER);
END overload;</div>
        <p>Which of the following code lines will result in a compilation error when executed after the package is compiled?</p>
        <div class="options">
            <div class="option">overload.test(p_first=>1);</div>
            <div class="option">overload.test(p_in=>1);</div>
            <div class="option">overload.test(1);</div>
            <div class="option">None of the above will result in a compilation error.</div>
        </div>
        <div class="answer">Answer: overload.test(1);</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>overload.test(p_first=>1);</strong> This is a named parameter call, explicitly specifying the p_first parameter. The compiler can clearly identify which procedure to invoke, so no compilation error occurs.</li>
                <li><strong>overload.test(p_in=>1);</strong> This is a named parameter call, explicitly specifying the p_in parameter. There is no ambiguity here so no compilation error occurs.</li>
                <li><strong>overload.test(1);</strong> This call uses an unnamed parameter. Since both overloaded procedures accept a single NUMBER parameter, the PL/SQL compiler cannot determine which procedure to invoke. This results in a compilation error due to ambiguity.</li>
                <li><strong>None of the above will result in a compilation error.</strong> This option is incorrect because, as explained, overload.test(1); will indeed cause a compilation error.</li>
            </ul>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 14: Q114</div>
        <p>Given the following PL/SQL package specification and body, which of the following statements is TRUE when executing the call overload.test('a');?</p>
        <div class="code">CREATE OR REPLACE PACKAGE overload IS
    PROCEDURE test(p_first VARCHAR2);
    PROCEDURE test(p_first CHAR);
END overload;

CREATE OR REPLACE PACKAGE BODY overload IS
    PROCEDURE test(p_first VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Using VARCHAR2 procedure: ' || p_first);
    END test;
    
    PROCEDURE test(p_first CHAR) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Using CHAR procedure: ' || p_first);
    END test;
END overload;</div>
        <div class="options">
            <div class="option">The call will raise the error PLS-00307: too many declarations of 'test' match this call due to ambiguity between VARCHAR2 and CHAR versions of the procedure.</div>
            <div class="option">The call will execute the VARCHAR2 version of the test procedure and display "Using VARCHAR2 procedure: a".</div>
            <div class="option">The call will execute the CHAR version of the test procedure and display "Using CHAR procedure: a".</div>
            <div class="option">The call will fail to compile because single-character string literals are not allowed as arguments in PL/SQL procedures.</div>
        </div>
        <div class="answer">Answer: The call will raise the error PLS-00307: too many declarations of 'test' match this call due to ambiguity between VARCHAR2 and CHAR versions of the procedure.</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <p>Given the ambiguity between VARCHAR2 and CHAR for a single-character string literal, the call overload.test('a'); would raise the PLS-00307 error.</p>
            <p>While string literals are treated as VARCHAR2 by default in PL/SQL, the presence of an overloaded procedure that accepts CHAR introduces ambiguity, leading to the error.</p>
            <p>The CHAR version of the procedure would be executed if we explicitly converted the string literal to CHAR using the CHAR function, but in this context, it introduces ambiguity.</p>
            <p>Single-character string literals are perfectly valid arguments in PL/SQL procedures, but the ambiguity between VARCHAR2 and CHAR is the issue here.</p>
            <p><strong>Topic:</strong> Creating Procedures and Using Parameters</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 15: Q115</div>
        <p>Given the following PL/SQL package specification, which of the following statements is TRUE when executing the provided PL/SQL blocks?</p>
        <div class="code">CREATE OR REPLACE PACKAGE mode_overload IS
    PROCEDURE demo(p_val IN NUMBER);
    PROCEDURE demo(p_val OUT NUMBER);
    PROCEDURE demo(p_val IN OUT NUMBER);
END mode_overload;</div>
        <div class="options">
            <div class="option">The block: 
                <div class="code">DECLARE
    v_num NUMBER;
BEGIN
    mode_overload.demo(v_num);
END;</div>
                will execute the demo procedure with the IN parameter mode without any errors.
            </div>
            <div class="option">The block: 
                <div class="code">DECLARE
    v_num NUMBER;
BEGIN
    mode_overload.demo(v_num);
END;</div>
                will raise the error PLS-00307: too many declarations of 'demo' match this call due to ambiguity among the overloaded procedures.
            </div>
        </div>
        <div class="answer">Answer: The block will raise the error PLS-00307: too many declarations of 'demo' match this call due to ambiguity among the overloaded procedures.</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <p>When you run each of the above blocks in an Oracle environment (like Oracle SQL Developer), you should encounter a compilation error PLS-00307 for all of them due to ambiguity among the overloaded procedures.</p>
            <p><strong>Topic:</strong> Creating Procedures and Using Parameters</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 16: Q116</div>
        <p>You are working on an Oracle database and are tasked with creating a trigger to enforce a business rule on the orders table. The rule states that for each new order, if the total order amount exceeds $10,000, a special discount of 5% should be applied. You decide to implement this using a row-level trigger.</p>
        <p>Here's your trigger definition:</p>
        <div class="code">CREATE OR REPLACE TRIGGER tr_discount_orders
    BEFORE INSERT ON orders
    FOR EACH ROW
    WHEN (NEW.order_amount > 10000)
BEGIN
    SELECT order_amount * 0.95 INTO :NEW.order_amount FROM orders WHERE order_id = :NEW.order_id;
END;</div>
        <p>After creating the trigger, you attempt to insert a new order with an amount of $11,000. However, you encounter an error. What is the most likely reason for this error?</p>
        <div class="options">
            <div class="option">The trigger is defined on the wrong table.</div>
            <div class="option">The trigger is trying to query a mutating table.</div>
            <div class="option">The discount calculation is incorrect.</div>
            <div class="option">The trigger should be defined as a statement-level trigger.</div>
        </div>
        <div class="answer">Answer: The trigger is trying to query a mutating table.</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <p>In Oracle, when a row-level trigger is fired, the table on which it is defined is considered to be "mutating." This means that it's in a state of flux, and its final state is not yet determined. As a result, it's not safe to query or modify the table from within the trigger, as it can lead to unpredictable results. In the provided trigger definition, the trigger is trying to query the orders table while it's in the process of being modified, leading to a "mutating table" error.</p>
            <p>To address this, the logic should be revised to avoid querying the orders table within the trigger.</p>
            <p><strong>Alternative Solutions:</strong></p>
            <ul>
                <li><strong>Use of a Statement-Level Trigger:</strong> While a statement-level trigger avoids the mutating table issue, it does not have access to each individual row's data, making it unsuitable for applying a row-specific discount.</li>
                <li><strong>Using a Compound Trigger or Other Mechanisms:</strong> To enforce such business rules while avoiding mutating table errors, alternative approaches like compound triggers, using a package to hold interim values, or implementing the logic in application code can be considered.</li>
            </ul>
            <p><strong>Topic:</strong> Creating Compound, DDL, and Event Database Triggers</p>
        </div>
    </div>

    <div class="question">
        <div class="question-number">Question 17: Q117</div>
        <p>You are tasked with implementing an audit mechanism for a database. Every time a specific table is updated, you want to log the changes in an audit table without affecting the main transaction. Which Oracle feature would be most suitable for this requirement?</p>
        <div class="options">
            <div class="option">Using a simple AFTER UPDATE trigger on the table.</div>
            <div class="option">Using a BEFORE UPDATE trigger with a COMMIT statement.</div>
            <div class="option">Using a trigger with PRAGMA AUTONOMOUS_TRANSACTION</div>
            <div class="option">Using a stored procedure with a ROLLBACK statement.</div>
        </div>
        <div class="answer">Answer: Using a trigger with PRAGMA AUTONOMOUS_TRANSACTION</div>
        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><strong>Using a simple AFTER UPDATE trigger on the table:</strong> While an AFTER UPDATE trigger can be used to log changes, it operates within the same transaction as the main DML operation. If the main transaction is rolled back, the changes made by the trigger will also be rolled back, making it unsuitable for independent auditing.</li>
                <li><strong>Using a BEFORE UPDATE trigger with a COMMIT statement:</strong> COMMIT statements within triggers can lead to unexpected behavior and are generally not recommended. Additionally, BEFORE UPDATE triggers are used to modify or validate data before it's updated, not for logging purposes.</li>
                <li><strong>Using